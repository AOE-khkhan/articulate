{"version":3,"sources":["../../../../server/lib/services/agent/agent.converse.service.js"],"names":["module","exports","id","sessionId","text","timezone","debug","additionalKeys","requestId","server","app","redis","handlebars","services","agentService","contextService","globalService","documentService","webhookResponses","updateLifespanOfSlots","performance","timerify","conversationStateObject","Object","keys","context","savedSlots","forEach","slot","savedSlot","remainingLife","getKeywordsFromRasaResults","rasaResults","_","flatMap","category","keywords","map","keyword","getBestRasaResult","categoryClassifierThreshold","multiCategory","rasaResult","recognizedCategory","length","categoryScore","getActionData","agentActions","action","filter","agentAction","actionName","name","getModifierData","agentKeywords","agentModifiers","flatten","modifiers","modifier","keywordName","modifierName","getActionByName","getCategoryByName","agentCategories","categoryName","agentCategory","getLastContextWithValidSlots","recognizedKeywords","recognizedKeywordsNames","keepGoing","contextIndex","lastValidContext","contextSlots","slots","intersection","cloneDeep","recognizedKeywordsArePartOfTheContext","results","recognizedKeyword","indexOf","compact","response","parse","responses","converseUpdateContextFrames","frames","converseGenerateResponseFallback","agent","categories","confidence","actionThreshold","currentFrame","frame","push","actionResponse","converseGenerateResponse","currentFrameSlotsKeywords","actions","Promise","reject","message","storeDataInQueue","indexOfActionInQueue","actionQueue","responseQueue","saveContextQueues","update","data","removeFromQueue","index","indexOnQueue","splice","moveOnQueue","oldIndex","newIndex","actionIndex","some","tempAction","tempIndex","tempActionData","tempSlot","getResponsesFromQueue","actionsToRemove","every","actionWasFulfilled","textResponse","getResponseOfChainedAction","requiredSlotNames","isRequired","missingSlots","currentSlotValue","slotName","undefined","Array","isArray","converseCompileResponseTemplates","textPrompts","templateContext","isTextPrompt","assign","useWebhook","modelPath","webhook","model","MODEL_AGENT","MODEL_ACTION","MODEL_WEBHOOK","findInModelPath","isFindById","isSingleResult","skip","limit","direction","field","webhookResponse","converseCallWebhook","url","webhookUrl","templatePayload","webhookPayload","payloadType","webhookPayloadType","method","webhookVerb","headers","webhookHeaders","username","webhookUser","password","webhookPassword","chainResponseActions","responseActions","CSO_AGENT","currentQueueIndex","responseAction","AgentModel","factory","ParsedDocument","returnModel","recognizedActionNames","PARAM_DOCUMENT_RASA_RESULTS","split","RASA_INTENT_SPLIT_SYMBOL","allProperties","loadAllLinked","parentModel","MODEL_CATEGORY","MODEL_KEYWORD","storeInQueue","reduce","previousPromise","recognizedActionName","finalResponse","findBySession","loadFrames","error","statusCode","create","CSO_CONTEXT","last","docId","CSO_TIMEZONE_DEFAULT","isEmpty","mapKeys","value","key","agentToolResponse","cleanAgentToolResponse","postFormatPayloadToUse","usedPostFormatAction","usePostFormat","postFormat","postFormatPayload","compiledPostFormat","compile","processedPostFormat","processedPostFormatJson","JSON","errorMessage","console","responseWithError","postFormatting","resolve","textResponses","responsesFromQueue","concat","join","converseResult","isParseError","missingCategories","missingTrainedCategories"],"mappings":"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","sourcesContent":["/* eslint-disable prefer-arrow-callback */\nimport _ from 'lodash';\nimport { performance } from 'perf_hooks';\nimport {\n    CSO_AGENT,\n    CSO_CONTEXT,\n    CSO_TIMEZONE_DEFAULT,\n    MODEL_ACTION,\n    MODEL_AGENT,\n    MODEL_CATEGORY,\n    MODEL_KEYWORD,\n    MODEL_WEBHOOK,\n    PARAM_DOCUMENT_RASA_RESULTS,\n    RASA_INTENT_SPLIT_SYMBOL\n} from '../../../util/constants';\nimport GlobalDefaultError from '../../errors/global.default-error';\nimport RedisErrorHandler from '../../errors/redis.error-handler';\n\nmodule.exports = async function ({ id, sessionId, text, timezone, debug = false, additionalKeys = null, requestId = null }) {\n\n    const { redis, handlebars } = this.server.app;\n    const { agentService, contextService, globalService, documentService } = await this.server.services();\n    const webhookResponses = [];\n\n    //MARK: reduce the remaining life of the saved slots\n    const updateLifespanOfSlots = performance.timerify(function updateLifespanOfSlots(conversationStateObject) {\n\n        Object.keys(conversationStateObject.context.savedSlots).forEach(slot => {\n            const savedSlot = conversationStateObject.context.savedSlots[slot];\n            if (savedSlot.remainingLife > -1) {\n                if (savedSlot.remainingLife > 0) {\n                    //1 is the shortest value of life, after that it is set to null as 0 is infinity\n                    if (savedSlot.remainingLife === 1) {\n                        savedSlot.remainingLife = null;\n                    }\n                    else {\n                        savedSlot.remainingLife--;\n                    }\n                }\n            }\n        });\n        //Removes all the slots that doesn't have a remaining life\n        Object.keys(conversationStateObject.context.savedSlots).forEach((slot) => {\n            if (!conversationStateObject.context.savedSlots[slot].remainingLife) {\n                delete conversationStateObject.context.savedSlots[slot];\n            }\n        });\n    });\n\n    //MARK: get all the keywords for all the categories\n    const getKeywordsFromRasaResults = performance.timerify(function getKeywordsFromRasaResults({ rasaResults }) {\n\n        return _.flatMap(rasaResults, (category) => {\n            category.keywords = _.map(category.keywords, (keyword) => {\n\n                //MARK: assigns category name to keyword\n                keyword.category = category.category;\n                return keyword;\n            });\n            return category.keywords;\n        });\n    });\n\n    //MARK: returns the category recognizer, or the only category or just list of keywords\n    const getBestRasaResult = performance.timerify(function getBestRasaResult({ rasaResults, categoryClassifierThreshold, multiCategory }) {\n        let rasaResult = {};\n\n        const recognizedCategory = rasaResults[0];\n\n        if (multiCategory) {\n            //MARK: if there is more than one category and this exceeds the agent.categoryClassifierThreshold then return it\n            if (rasaResults.length > 0 && recognizedCategory.categoryScore > categoryClassifierThreshold) {\n                rasaResult = recognizedCategory;\n            }\n            else {\n                //MARK: if there is only one then return it\n                if (rasaResults.length === 1) {\n                    rasaResult = recognizedCategory;\n                }\n                //MARK: if there is more than one then collect all keywords\n                //MARK: but this will have a different structure?\n                else {\n                    rasaResult.keywords = getKeywordsFromRasaResults({ rasaResults });\n                }\n            }\n        }\n        else {\n            rasaResult = recognizedCategory;\n        }\n\n        return rasaResult;\n    });\n\n    //MARK: if there is an action, look for it in the agent actions, return the first one\n    const getActionData = performance.timerify(function getActionData({ rasaResult, agentActions }) {\n\n        //MARK: rasaResult comes from getBestRasaResult\n        if (rasaResult.action) {\n\n            return _.filter(agentActions, (agentAction) => {\n\n                return agentAction.actionName === rasaResult.action.name;\n            })[0];\n        }\n        return null;\n    });\n\n    //MARK: if there is a modifier, look for it in the agent keywords, return the first one\n    const getModifierData = performance.timerify(function getModifierData({ rasaResult, agentKeywords }) {\n\n        //MARK: rasaResult comes from getBestRasaResult\n        if (rasaResult.action) {\n\n            const agentModifiers = _.flatten(_.map(agentKeywords, (keyword) => {\n\n                return _.map(keyword.modifiers, (modifier) => {\n\n                    modifier.keyword = keyword.keywordName;\n                    return modifier;\n                });\n            }));\n            return _.filter(agentModifiers, (modifier) => {\n\n                return modifier.modifierName === rasaResult.action.name;\n            })[0];\n        }\n        return null;\n    });\n\n    //MARK: find and action from the agent object by name\n    const getActionByName = performance.timerify(function getActionByName({ actionName, agentActions }) {\n\n        return _.filter(agentActions, (agentAction) => {\n\n            return agentAction.actionName === actionName;\n        })[0];\n    });\n\n    //MARK: find category from agent.categories by name\n    const getCategoryByName = performance.timerify(function getCategoryByName({ agentCategories, categoryName }) {\n\n        return _.filter(agentCategories, (agentCategory) => {\n\n            return agentCategory.categoryName === categoryName;\n        })[0];\n    });\n\n    //MARK: look into all the context until you get one with slots\n    const getLastContextWithValidSlots = performance.timerify(function getLastContextWithValidSlots({ context, recognizedKeywords }) {\n\n        const recognizedKeywordsNames = _.map(recognizedKeywords, 'keyword');\n        let keepGoing = true;\n        let contextIndex = context.length - 1;\n        let lastValidContext = null;\n        while (keepGoing && contextIndex !== -1) {\n\n            const contextSlots = context[contextIndex].slots ? Object.keys(context[contextIndex].slots) : [];\n            const intersection = _.intersection(recognizedKeywordsNames, contextSlots);\n            if (intersection.length > 0) {\n                keepGoing = false;\n                lastValidContext = _.cloneDeep(context[contextIndex]);\n            }\n            contextIndex--;\n        }\n        return lastValidContext;\n    });\n\n    const recognizedKeywordsArePartOfTheContext = performance.timerify(function recognizedKeywordsArePartOfTheContext({ slots, recognizedKeywords }) {\n\n        let results = _.map(recognizedKeywords, (recognizedKeyword) => {\n\n            return Object.keys(slots).indexOf(recognizedKeyword.keyword) > -1;\n        });\n        results = _.compact(results);\n        return results.length > 0;\n    });\n\n    const response = async ({ conversationStateObject }) => {\n\n        updateLifespanOfSlots(conversationStateObject);\n        //MARK: CSO.parse ===true\n        if (conversationStateObject.parse) {\n            //MARK: if the model recognized an action\n            if (conversationStateObject.action && !conversationStateObject.modifier) {\n                //MARK: if there is an action but no responses call RespondFallback and persist context\n                if (!conversationStateObject.action.responses || conversationStateObject.action.responses.length === 0) {\n                    await agentService.converseUpdateContextFrames({ id: conversationStateObject.context.id, frames: conversationStateObject.context.frames });\n                    return agentService.converseGenerateResponseFallback({ agent: conversationStateObject.agent });\n                }\n                //MARK: CSO.parse ===false\n                //MARK: get category using rasaResult category name\n                conversationStateObject.category = getCategoryByName({ agentCategories: conversationStateObject.agent.categories, categoryName: conversationStateObject.rasaResult.category });\n                //MARK: if there is an action and a category, check if the action confidence ia bigger than the category threshold === true\n                if ((!conversationStateObject.agent.multiCategory && conversationStateObject.rasaResult.action.confidence > conversationStateObject.agent.categoryClassifierThreshold) ||\n                    (conversationStateObject.agent.multiCategory && conversationStateObject.category && conversationStateObject.rasaResult.action.confidence > conversationStateObject.category.actionThreshold)) {\n                    //MARK: if the current context is empty or the current OR if the action name is the same as the current context action add a new frame with empty slots\n                    if (!conversationStateObject.currentFrame || (conversationStateObject.rasaResult.action.name !== conversationStateObject.currentFrame.action)) {\n                        const frame = {\n                            action: conversationStateObject.rasaResult.action.name,\n                            slots: {}\n                        };\n                        conversationStateObject.context.frames.push(frame);\n                        //MARK: get the last context, but it is the same that was pushed above?\n                        conversationStateObject.currentFrame = frame;\n                    }\n                    const actionResponse = await agentService.converseGenerateResponse({\n                        conversationStateObject\n                    });\n                    //TODO: agentService.converseGenerateResponse, this needs to be removed from there\n                    await agentService.converseUpdateContextFrames({ id: conversationStateObject.context.id, frames: conversationStateObject.context.frames });\n                    return actionResponse;\n                }\n            }\n\n            //MARK: if the model recognized a modifier\n            if (conversationStateObject.modifier && conversationStateObject.action) {\n                //MARK: get the slots of the current context action\n                const currentFrameSlotsKeywords = _.map(conversationStateObject.action.slots, 'keyword');\n                //MARK: if the modifier applies to the current context\n                if (currentFrameSlotsKeywords.indexOf(conversationStateObject.modifier.keyword) !== -1) {\n                    //MARK: generate response using the modifier\n                    const actionResponse = await agentService.converseGenerateResponse({\n                        conversationStateObject\n                    });\n                    //TODO: agentService.converseGenerateResponse, this needs to be removed from there\n                    await agentService.converseUpdateContextFrames({ id: conversationStateObject.context.id, frames: conversationStateObject.context.frames });\n                    return actionResponse;\n                }\n            }\n            //MARK: if there is NO action then use the rasaResult.keywords else get them from getKeywordsFromRasaResults\n            //MARK: I think this line doesn't do much since we already called getKeywordsFromRasaResults before to get rasaResult, the only difference is that we are saving the entire rasaResult instead of just the keywords\n            const recognizedKeywords = conversationStateObject.rasaResult.action ? getKeywordsFromRasaResults(conversationStateObject) : conversationStateObject.rasaResult.keywords;\n            //MARK: conversationStateObject.currentFrame === true\n            if (conversationStateObject.currentFrame) {\n                //MARK: recognizedKeywords>0\n                if (recognizedKeywords.length > 0) {\n                    //MARK: if there are slots and the recognizedKeywords are part of the context == true\n                    if (conversationStateObject.currentFrame.slots && Object.keys(conversationStateObject.currentFrame.slots).length > 0 && recognizedKeywordsArePartOfTheContext({ slots: conversationStateObject.currentFrame.slots, recognizedKeywords })) {\n                        //MARK: update action object from the action of the context\n                        conversationStateObject.action = getActionByName({ actionName: conversationStateObject.currentFrame.action, agentActions: conversationStateObject.agent.actions });\n                        const actionResponse = agentService.converseGenerateResponse({\n                            conversationStateObject\n                        });\n                        //TODO: agentService.converseGenerateResponse, this needs to be removed from there\n                        await agentService.converseUpdateContextFrames({ context: conversationStateObject.context });\n                        return actionResponse;\n                    }\n                    //MARK: recognizedKeywords <= 0\n                    //MARK: if there are no slots then we get the last one with valid slots, update teh context list and set the last context, then get the action used by that context\n                    const lastValidContext = getLastContextWithValidSlots({ context: conversationStateObject.context, recognizedKeywords });\n                    if (lastValidContext) {\n                        conversationStateObject.context.push(lastValidContext);\n                        conversationStateObject.currentFrame = lastValidContext;\n                        conversationStateObject.action = getActionByName({ actionName: conversationStateObject.currentFrame.name, agentActions: conversationStateObject.agent.actions });\n                        const actionResponse = agentService.converseGenerateResponse({\n                            conversationStateObject\n                        });\n                        //TODO: agentService.converseGenerateResponse, this needs to be removed from there\n                        await agentService.converseUpdateContextFrames({ context: conversationStateObject.context });\n                        return actionResponse;\n                    }\n                }\n            }\n            return agentService.converseGenerateResponseFallback({ agent: conversationStateObject.agent });\n        }\n        return Promise.reject(GlobalDefaultError({\n            message: `Sorry, the engine wasn't able to parse your text`\n        }));\n    };\n\n    const storeDataInQueue = ({ conversationStateObject, action, response, indexOfActionInQueue }) => {\n\n        if (indexOfActionInQueue === -1) {\n            conversationStateObject.context.actionQueue.push({\n                action,\n                slots: conversationStateObject.currentFrame.slots\n            });\n            conversationStateObject.context.responseQueue.push({ ...response });\n        }\n        else {\n            conversationStateObject.context.actionQueue[indexOfActionInQueue] = {\n                action,\n                slots: conversationStateObject.currentFrame.slots\n            };\n            conversationStateObject.context.responseQueue[indexOfActionInQueue] = { ...response };\n        }\n    };\n\n    const saveContextQueues = async ({ context }) => {\n        await contextService.update({\n            sessionId: context.sessionId,\n            data: {\n                actionQueue: context.actionQueue,\n                responseQueue: context.responseQueue\n            }\n        });\n    };\n\n    const removeFromQueue = async ({ conversationStateObject, action }) => {\n        const index = indexOnQueue({ actionQueue: conversationStateObject.context.actionQueue, action });\n        conversationStateObject.context.actionQueue.splice(index, 1);\n        conversationStateObject.context.responseQueue.splice(index, 1);\n        await contextService.update({\n            sessionId: conversationStateObject.context.sessionId,\n            data: {\n                actionQueue: conversationStateObject.context.actionQueue,\n                responseQueue: conversationStateObject.context.responseQueue\n            }\n        });\n    };\n\n    const moveOnQueue = ({ context, oldIndex, newIndex }) => {\n        context.actionQueue.splice(newIndex, 0, context.actionQueue.splice(oldIndex, 1)[0]);\n        context.responseQueue.splice(newIndex, 0, context.responseQueue.splice(oldIndex, 1)[0]);\n    };\n\n    const indexOnQueue = ({ actionQueue, action, modifier, agentActions }) => {\n\n        let actionIndex = -1;\n        if (modifier) {\n            actionQueue.some((tempAction, tempIndex) => {\n\n                const tempActionData = getActionByName({ actionName: tempAction.action, agentActions });\n                tempActionData.slots.some((tempSlot) => {\n\n                    if (tempSlot.keyword === modifier.keyword) {\n                        actionIndex = tempIndex;\n                    }\n                    return actionIndex !== -1;\n                });\n                return actionIndex !== -1;\n            });\n        }\n        else {\n            actionQueue.some((tempAction, tempIndex) => {\n\n                if (tempAction.action === action) {\n                    actionIndex = tempIndex;\n                }\n                return actionIndex !== -1;\n            });\n        }\n\n        return actionIndex;\n    };\n\n    const getResponsesFromQueue = ({ context }) => {\n\n        const responses = [];\n        const actionsToRemove = [];\n        context.responseQueue.every((response, index) => {\n\n            if (response.actionWasFulfilled) {\n                responses.push(context.responseQueue[index].textResponse);\n                actionsToRemove.push(index);\n                return true;\n            }\n\n            if (index === 0) {\n                responses.push(context.responseQueue[index].textResponse);\n            }\n            return false;\n\n        });\n        context.actionQueue = _.filter(context.actionQueue, (action, index) => {\n            return actionsToRemove.indexOf(index) === -1;\n        });\n        context.responseQueue = _.filter(context.responseQueue, (response, index) => {\n            return actionsToRemove.indexOf(index) === -1;\n        });\n        return responses;\n    };\n\n    const getResponseOfChainedAction = async ({ action, conversationStateObject }) => {\n\n        const response = {\n            actionWasFulfilled: true\n        };\n        //If the chained action have required slots, check if those can be pulled from the current context\n        const requiredSlotNames = _.compact(_.map(action.slots, (slot) => {\n\n            return slot.isRequired ? slot : null;\n        }));\n        if (requiredSlotNames.length > 0) {\n            const missingSlots = _.filter(requiredSlotNames, (slot) => {\n\n                if (conversationStateObject.slots) {\n                    const currentSlotValue = conversationStateObject.slots[slot.slotName];\n                    return (currentSlotValue === undefined) || (currentSlotValue === '') || (currentSlotValue === null) || (Array.isArray(currentSlotValue) && currentSlotValue.length === 0);\n                }\n                return true;\n            });\n            if (missingSlots.length > 0) {\n                response.actionWasFulfilled = false;\n                const textResponse = await agentService.converseCompileResponseTemplates({ responses: missingSlots[0].textPrompts, templateContext: conversationStateObject, isTextPrompt: true });\n                Object.assign(response, { ...textResponse });\n                return response;\n            }\n        }\n        if (action.useWebhook || conversationStateObject.agent.useWebhook) {\n            let modelPath, webhook;\n            if (action.useWebhook) {\n                modelPath = [\n                    {\n                        model: MODEL_AGENT,\n                        id: conversationStateObject.agent.id\n                    },\n                    {\n                        model: MODEL_ACTION,\n                        id: action.id\n                    },\n                    {\n                        model: MODEL_WEBHOOK\n                    }\n                ];\n                webhook = await globalService.findInModelPath({ modelPath, isFindById: false, isSingleResult: true });\n            }\n            else {\n                modelPath = [\n                    {\n                        model: MODEL_AGENT,\n                        id: conversationStateObject.agent.id\n                    },\n                    {\n                        model: MODEL_WEBHOOK\n                    }\n                ];\n                webhook = await globalService.findInModelPath({ modelPath, isFindById, isSingleResult, skip, limit, direction, field });\n            }\n            const webhookResponse = await agentService.converseCallWebhook({\n                url: webhook.webhookUrl,\n                templatePayload: webhook.webhookPayload,\n                payloadType: webhook.webhookPayloadType,\n                method: webhook.webhookVerb,\n                headers: webhook.webhookHeaders,\n                username: webhook.webhookUser ? webhook.webhookUser : undefined,\n                password: webhook.webhookPassword ? webhook.webhookPassword : undefined,\n                templateContext: conversationStateObject\n            });\n            if (webhookResponse.textResponse) {\n                return { textResponse: webhookResponse.textResponse, actions: webhookResponse.actions ? webhookResponse.actions : [], actionWasFulfilled: true, webhookResponse };\n            }\n            conversationStateObject.webhookResponse = { ...webhookResponse };\n            const textResponse = await agentService.converseCompileResponseTemplates({ responses: action.responses, templateContext: conversationStateObject });\n            return { ...textResponse, webhookResponse, actionWasFulfilled: true };\n        }\n        const textResponse = await agentService.converseCompileResponseTemplates({ responses: action.responses, templateContext: conversationStateObject });\n        Object.assign(response, { ...textResponse });\n        return response;\n    };\n\n    const chainResponseActions = async ({ conversationStateObject, responseActions }) => {\n\n        const agentActions = conversationStateObject[CSO_AGENT].actions;\n        let currentQueueIndex = 0;\n\n        for (let responseAction of responseActions) {\n            let agentAction = _.filter(agentActions, (tempAction) => {\n\n                return tempAction.actionName === responseAction;\n            });\n            if (agentAction.length > 0) {\n                agentAction = agentAction[0];\n                const indexOfActionInQueue = indexOnQueue({ actionQueue: conversationStateObject.context.actionQueue, action: agentAction.actionName });\n                if (indexOfActionInQueue !== -1) {\n                    moveOnQueue({\n                        context: conversationStateObject.context,\n                        oldIndex: indexOfActionInQueue,\n                        newIndex: currentQueueIndex\n                    });\n                    currentQueueIndex++;\n                }\n                else {\n                    conversationStateObject.context.actionQueue.push({\n                        action: agentAction.actionName,\n                        slots: {}\n                    });\n                    const response = await getResponseOfChainedAction({ action: agentAction, conversationStateObject });\n                    if (response.webhookResponse) {\n                        webhookResponses.push(response.webhookResponse);\n                    }\n                    conversationStateObject.context.responseQueue.push({ ...response });\n                }\n            }\n        }\n    };\n\n    const conversationStateObject = {};\n\n    try {\n        const AgentModel = await redis.factory(MODEL_AGENT, id);\n\n        const ParsedDocument = await agentService.parse({ AgentModel, text, timezone, returnModel: true, sessionId });\n        const recognizedActionNames = ParsedDocument[PARAM_DOCUMENT_RASA_RESULTS][0].action.name.split(RASA_INTENT_SPLIT_SYMBOL);\n\n        conversationStateObject[CSO_AGENT] = AgentModel.allProperties();\n        conversationStateObject[CSO_AGENT].actions = await globalService.loadAllLinked({ parentModel: AgentModel, model: MODEL_ACTION, returnModel: false });\n        conversationStateObject[CSO_AGENT].categories = await globalService.loadAllLinked({ parentModel: AgentModel, model: MODEL_CATEGORY, returnModel: false });\n        conversationStateObject[CSO_AGENT].keywords = await globalService.loadAllLinked({ parentModel: AgentModel, model: MODEL_KEYWORD, returnModel: false });\n\n        let storeInQueue = false;\n        let currentQueueIndex = 0;\n\n        const responses = await recognizedActionNames.reduce(async (previousPromise, recognizedActionName) => {\n            let finalResponse = null;\n            const data = await previousPromise;\n\n            //This block will handle sessionIds that doesn't exists\n            //If the sessionId doesn't exists it creates one context for that session\n            //And adds a frames attribute which is an empty array\n            //The frames will be updated once converse resolve the value\n            let context;\n            try {\n                context = await contextService.findBySession({ sessionId, loadFrames: true });\n            }\n            catch (error) {\n                if (error.statusCode && error.statusCode === 404) {\n                    context = await contextService.create({ data: { sessionId } });\n                    context.frames = [];\n                }\n                else {\n                    return Promise.reject(error);\n                }\n            }\n            conversationStateObject[CSO_CONTEXT] = context;\n            //MARK: Get the last frame context from the context array\n            conversationStateObject.currentFrame = _.last(conversationStateObject.context.frames);\n\n            ParsedDocument[PARAM_DOCUMENT_RASA_RESULTS][0].action.name = recognizedActionName;\n            conversationStateObject.docId = ParsedDocument.id;\n            conversationStateObject.parse = ParsedDocument[PARAM_DOCUMENT_RASA_RESULTS];\n            conversationStateObject.text = text;\n            conversationStateObject.sessionId = sessionId;\n            conversationStateObject.timezone = timezone || conversationStateObject[CSO_AGENT].timezone || CSO_TIMEZONE_DEFAULT;\n            if (!_.isEmpty(additionalKeys)) {\n                _.mapKeys(additionalKeys, (value, key) => {\n\n                    if (!conversationStateObject[key]) {\n                        conversationStateObject[key] = value;\n                    }\n                });\n            }\n            let indexOfActionInQueue = -1;\n            //MARK: get category recognizer, 1 category or list of keywords from all categories\n            conversationStateObject.rasaResult = getBestRasaResult({ rasaResults: conversationStateObject.parse, categoryClassifierThreshold: conversationStateObject.agent.categoryClassifierThreshold, multiCategory: conversationStateObject.agent.multiCategory });\n            //MARK: if there is an action, look for it in the agent actions\n            conversationStateObject.action = getActionData({ rasaResult: conversationStateObject.rasaResult, agentActions: conversationStateObject.agent.actions });\n            if (!conversationStateObject.action) {\n                //MARK: look if the model recognized a modifier\n                conversationStateObject.modifier = getModifierData({ rasaResult: conversationStateObject.rasaResult, agentKeywords: conversationStateObject.agent.keywords });\n                if (conversationStateObject.modifier) {\n                    //MARK: search if there is an action in the queue that can be modified by the modifier\n                    indexOfActionInQueue = indexOnQueue({ actionQueue: conversationStateObject.context.actionQueue, modifier: conversationStateObject.modifier, agentActions: conversationStateObject.agent.actions });\n                    if (indexOfActionInQueue !== -1) {\n                        //MARK: if there is an action that can be modified by the modifier, then get its data\n                        conversationStateObject.action = getActionByName({ actionName: conversationStateObject.context.actionQueue[0].action, agentActions: conversationStateObject.agent.actions });\n                    }\n                    else {\n                        //MARK: if the modifier doesn't modifies any action in the action queue, get latest action in context\n                        if (conversationStateObject.currentFrame) {\n                            conversationStateObject.action = getActionByName({ actionName: conversationStateObject.currentFrame.action, agentActions: conversationStateObject.agent.actions });\n                        }\n                    }\n                }\n            }\n            else {\n                indexOfActionInQueue = indexOnQueue({ actionQueue: conversationStateObject.context.actionQueue, action: conversationStateObject.action.actionName });\n            }\n\n            if (indexOfActionInQueue !== -1) {\n                moveOnQueue({\n                    context: conversationStateObject.context,\n                    oldIndex: indexOfActionInQueue,\n                    newIndex: currentQueueIndex\n                });\n                currentQueueIndex++;\n            }\n\n            const agentToolResponse = await response({ conversationStateObject });\n            if (agentToolResponse.webhookResponse) {\n                webhookResponses.push(agentToolResponse.webhookResponse);\n            }\n            const cleanAgentToolResponse = {\n                docId: agentToolResponse.docId,\n                textResponse: agentToolResponse.textResponse,\n                actionWasFulfilled: agentToolResponse.actionWasFulfilled,\n                actions: agentToolResponse.actions\n            };\n            storeInQueue = storeInQueue || !cleanAgentToolResponse.actionWasFulfilled;\n\n            cleanAgentToolResponse.docId = conversationStateObject.docId;\n            let postFormatPayloadToUse;\n            let usedPostFormatAction;\n            if (conversationStateObject.action && conversationStateObject.action.usePostFormat) {\n                postFormatPayloadToUse = conversationStateObject.action.postFormat.postFormatPayload;\n                usedPostFormatAction = true;\n            }\n            else if (conversationStateObject.agent.usePostFormat) {\n                usedPostFormatAction = false;\n                postFormatPayloadToUse = conversationStateObject.agent.postFormat.postFormatPayload;\n            }\n            if (postFormatPayloadToUse) {\n                try {\n                    const compiledPostFormat = handlebars.compile(postFormatPayloadToUse);\n                    const processedPostFormat = compiledPostFormat({ ...conversationStateObject, ...{ textResponse: cleanAgentToolResponse.textResponse } });\n                    const processedPostFormatJson = JSON.parse(processedPostFormat);\n                    processedPostFormatJson.docId = cleanAgentToolResponse.docId;\n                    if (!processedPostFormatJson.textResponse) {\n                        processedPostFormatJson.textResponse = cleanAgentToolResponse.textResponse;\n                    }\n                    finalResponse = processedPostFormatJson;\n                }\n                catch (error) {\n                    const errorMessage = usedPostFormatAction ? 'Error formatting the post response using action POST format : ' : 'Error formatting the post response using agent POST format : ';\n                    console.error(errorMessage, error);\n                    const responseWithError = { ...{ postFormatting: errorMessage + error }, cleanAgentToolResponse };\n                    finalResponse = responseWithError;\n                }\n            }\n            else {\n                finalResponse = cleanAgentToolResponse;\n            }\n            if (storeInQueue) {\n                await storeDataInQueue({ conversationStateObject, action: conversationStateObject.action ? conversationStateObject.action.actionName : recognizedActionName, response: finalResponse, indexOfActionInQueue });\n            }\n            else {\n                if (indexOfActionInQueue !== -1) {\n                    await removeFromQueue({ conversationStateObject, action: recognizedActionName });\n                }\n                data.push(finalResponse);\n            }\n            if (cleanAgentToolResponse.actionWasFulfilled && cleanAgentToolResponse.actions && cleanAgentToolResponse.actions.length > 0) {\n                await chainResponseActions({ conversationStateObject, responseActions: cleanAgentToolResponse.actions });\n            }\n            return data;\n        }, Promise.resolve([]));\n        let textResponses = _.map(responses, 'textResponse');\n        //extract responses from previous answers\n        const responsesFromQueue = getResponsesFromQueue({\n            context: conversationStateObject.context\n        });\n        textResponses = textResponses.concat(responsesFromQueue);\n        const textResponse = textResponses.length === 1 ? textResponses : textResponses.join(' ');\n        await saveContextQueues({ context: conversationStateObject.context });\n        await documentService.update({ id: conversationStateObject.docId, data: { webhookResponses } });\n        await contextService.update({\n            sessionId: conversationStateObject.context.sessionId,\n            data: {\n                savedSlots: conversationStateObject.context.savedSlots\n            }\n        });\n\n        const converseResult = {\n            textResponse,\n            docId: conversationStateObject.docId,\n            responses\n        };\n        if (debug) {\n            const { context, currentFrame, parse, docId } = conversationStateObject;\n            converseResult.conversationStateObject = {\n                docId,\n                context,\n                currentFrame,\n                parse,\n                webhookResponses\n            };\n        }\n        return converseResult;\n    }\n    catch (error) {\n\n        if (error.isParseError) {\n            if (error.missingCategories) {\n                return {\n                    textResponse: 'I don\\'t have any knowledge in my brain yet. Please teach me something.'\n                };\n            }\n            if (error.missingTrainedCategories) {\n                return {\n                    textResponse: 'Ok I know you have teach me a couple of things, but first you have to train me.'\n                };\n            }\n        }\n        throw RedisErrorHandler({ error });\n    }\n};\n"],"file":"agent.converse.service.js"}